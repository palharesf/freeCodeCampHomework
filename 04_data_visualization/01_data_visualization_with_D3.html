<!-- Exercise permalink: https://www.freecodecamp.org/learn/data-visualization/data-visualization-with-d3/add-document-elements-with-d3 -->

<!-- The select() method selects one element from the document. It takes an argument for the name of the element you want and returns an HTML node for the first element in the document that matches the name. Here's an example:

const anchor = d3.select("a");

The above example finds the first anchor tag on the page and saves an HTML node for it in the variable anchor. You can use the selection with other methods. The d3 part of the example is a reference to the D3 object, which is how you access D3 methods.
Two other useful methods are append() and text().
The append() method takes an argument for the element you want to add to the document. It appends an HTML node to a selected item, and returns a handle to that node.
The text() method either sets the text of the selected node, or gets the current text. To set the value, you pass a string as an argument inside the parentheses of the method.
Here's an example that selects an unordered list, appends a list item, and adds text:

d3.select("ul")
.append("li")
.text("Very important item")

D3 allows you to chain several methods together with periods to perform a number of actions in a row. -->

<body>
    <script>      
      d3.select("body")
        .append("h1")
        .text("Learning D3")
    </script>
</body>

<!-- D3 also has the selectAll() method to select a group of elements. It returns an array of HTML nodes for all the items in the document that match the input string. Here's an example to select all the anchor tags in a document:

const anchors = d3.selectAll("a");

Like the select() method, selectAll() supports method chaining, and you can use it with other methods. -->

<body>
    <ul>
      <li>Example</li>
      <li>Example</li>
      <li>Example</li>
    </ul>
    <script>
  
  d3.selectAll("li")
    .text("list item")
  
    </script>
</body>

<!-- The D3 library focuses on a data-driven approach. When you have a set of data, you can apply D3 methods to display it on the page.
Data comes in many formats, but this challenge uses a simple array of numbers. The first step is to make D3 aware of the data.
The data() method is used on a selection of DOM elements to attach the data to those elements. The data set is passed as an argument to the method.
A common workflow pattern is to create a new element in the document for each piece of data in the set. D3 has the enter() method for this purpose.
When enter() is combined with the data() method, it looks at the selected elements from the page and compares them to the number of data items in the set.
If there are fewer elements than data items, it creates the missing elements. Here is an example that selects a ul element and creates a new list item based on the number of entries in the array:

<body>
  <ul></ul>
  <script>
    const dataset = ["a", "b", "c"];
    d3.select("ul").selectAll("li")
      .data(dataset)
      .enter()
      .append("li")
      .text("New item");
  </script>
</body>

It may seem confusing to select elements that don't exist yet.
This code is telling D3 to first select the ul on the page. Next, select all list items, which returns an empty selection.
Then the data() method reviews the dataset and runs the following code three times, once for each item in the array.
The enter() method sees there are no li elements on the page, but it needs 3 (one for each piece of data in dataset).
New li elements are appended to the ul and have the text New item. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      d3.select("body")
        .selectAll("h2")
        .data(dataset)
        .enter()
        .append("h2")
        .text("New Title")
  
    </script>
</body>

<!-- In the previous challenge, you created a new h2 element for each item in the dataset array, but they all contained the same text, New Title.
This is because you have not made use of the data that is bound to each of the h2 elements. The D3 text() method can take a string or a callback function as an argument:

selection.text((d) => d)

In the example above, the parameter d refers to a single entry in the dataset that a selection is bound to.
Using the current example as context, the first h2 element is bound to 12, the second h2 element is bound to 31, the third h2 element is bound to 22, and so on. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      d3.select("body").selectAll("h2")
        .data(dataset)
        .enter()
        .append("h2")  
        .text((d) => d + " USD");
  
    </script>
</body>

<!-- D3 lets you add inline CSS styles on dynamic elements with the style() method, which takes a comma-separated key-value pair as an argument. Example:

selection.style("color","blue"); -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      d3.select("body").selectAll("h2")
        .data(dataset)
        .enter()
        .append("h2")
        .text((d) => (d + " USD"))  
        .style("font-family","verdana")

    </script>
</body>

<!-- You may want to color a data point blue if it has a value less than 20, and red otherwise.
The style() method accepts a callback function for conditional logic. It uses the d parameter to represent the data point:

selection.style("color", (d) => {

});

The style() method is not limited to setting the color - it can be used with other CSS properties as well. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      d3.select("body").selectAll("h2")
        .data(dataset)
        .enter()
        .append("h2")
        .text((d) => (d + " USD"))  
        .style("color", (d) => {
          return d < 20 ? "red" : "green"
        })
  
    </script>
</body>

<!-- The attr() method works the same way that style() does. It takes comma-separated values, and can use a callback function.
Here's an example to add a class of container to a selection:

selection.attr("class", "container");

Note that the class parameter will remain the same whenever you need to add a class and only the container parameter will change. -->

<style>
    .bar {
      width: 25px;
      height: 100px;
      display: inline-block;
      background-color: blue;
    }
</style>
<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      d3.select("body").selectAll("div")
        .data(dataset)
        .enter()
        .append("div")  
        .attr("class","bar")

    </script>
</body>

<!-- The previous challenges covered how to display data from an array and how to add CSS classes.
You can combine these lessons to create a simple bar chart. There are two steps to this:
    Create a div for each data point in the array
    Give each div a dynamic height, using a callback function in the style() method that sets height equal to the data value -->

<style>
    .bar {
        width: 25px;
        height: 100px;
        display: inline-block;
        background-color: blue;
    }
</style>
<body>
    <script>
        const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
    
        d3.select("body").selectAll("div")
        .data(dataset)
        .enter()
        .append("div")
        .attr("class", "bar")    
        .style("height",(d) => {
            return d + "px";
        })

    </script>
</body>

<!-- The last challenge created a bar chart, but there are a couple of formatting changes that could improve it:
    - Add space between each bar to visually separate them, which is done by adding a margin to the CSS for the bar class
    - Increase the height of the bars to better show the difference in values, which is done by multiplying the value by a number to scale the height -->

<style>
    .bar {
        width: 25px;
        height: 100px;    
        margin: 2px;        
        display: inline-block;
        background-color: blue;
    }
</style>
<body>
    <script>
        const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
    
        d3.select("body").selectAll("div")
        .data(dataset)
        .enter()
        .append("div")
        .attr("class", "bar")
        .style("height", (d) => (10*d + "px"))

    </script>
</body>

<!-- SVG is used to make common geometric shapes.
Since D3 maps data into a visual representation, it uses SVG to create the shapes for the visualization.
SVG shapes for a web page must go within an HTML svg tag.
CSS can be scalable when styles use relative units (such as vh, vw, or percentages), but using SVG is more flexible to build data visualizations. -->

<style>
  svg {
    background-color: pink;
  }
</style>
<body>
  <script>
    const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];

    const w = 500;
    const h = 100;

    const svg = d3.select("body")
                  .append("svg")
                  .style("width",w,)
                  .style("height",h)
  </script>
</body>

<!-- There are a number of supported shapes in SVG, such as rectangles and circles. They are used to display data.
For example, a rectangle (<rect>) SVG shape could create a bar in a bar chart.
When you place a shape into the svg area, you can specify where it goes with x and y coordinates. The origin point of (0, 0) is in the upper-left corner.
Positive values for x push the shape to the right, and positive values for y push the shape down from the origin point.  
An SVG rect has four attributes. There are the x and y coordinates for where it is placed in the svg area. It also has a height and width to specify the size. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h)
  
                    .append("rect")
                    .attr("width", 25)
                    .attr("height", 100)
                    .attr("x", 0)
                    .attr("y", 0)
  
    </script>
</body>

<!-- A previous challenge showed the format for how to create and append a div for each item in dataset:

d3.select("body").selectAll("div")
  .data(dataset)
  .enter()
  .append("div")

There are a few differences working with rect elements instead of div elements.
The rect elements must be appended to an svg element, not directly to the body.
Also, you need to tell D3 where to place each rect within the svg area. The bar placement will be covered in the next challenge. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", 0)
         .attr("y", 0)
         .attr("width", 25)
         .attr("height", 100);

    </script>
</body>

<!-- The last challenge created and appended a rectangle to the svg element for each point in dataset to represent a bar.
Unfortunately, they were all stacked on top of each other. The placement of a rectangle is handled by the x and y attributes.
They tell D3 where to start drawing the shape in the svg area.
The last challenge set them each to 0, so every bar was placed in the upper-left corner.
For a bar chart, all of the bars should sit on the same vertical level, which means the y value stays the same (at 0) for all bars.
The x value, however, needs to change as you add new bars. Remember that larger x values push items farther to the right.
As you go through the array elements in dataset, the x value should increase.The attr() method in D3 accepts a callback function to dynamically set that attribute.
The callback function takes two arguments, one for the data point itself (usually d) and one for the index of the data point in the array.
The second argument for the index is optional. Here's the format:

selection.attr("property", (d, i) => {

})

It's important to note that you do NOT need to write a for loop or use forEach() to iterate over the items in the data set.
Recall that the data() method parses the data set, and any method that's chained after data() is run once for each item in the data set. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => {  
          return i*30;
         })
         .attr("y", 0)
         .attr("width", 25)
         .attr("height", 100);
    </script>
</body>

<!-- The height of each bar can be set to the value of the data point in the array, similar to how the x value was set dynamically.

selection.attr("property", (d, i) => {

})

Here d would be the data point value, and i would be the index of the data point in the array. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => i * 30)
         .attr("y", 0)
         .attr("width", 25)
         .attr("height", (d, i) => {
            return d*3;
         });
    </script>
</body>

<!-- You may have noticed the bar chart looked like it's upside-down, or inverted. This is because of how SVG uses (x, y) coordinates.
In SVG, the origin point for the coordinates is in the upper-left corner. An x coordinate of 0 places a shape on the left edge of the SVG area.
A y coordinate of 0 places a shape on the top edge of the SVG area. Higher x values push the rectangle to the right. Higher y values push the rectangle down.
To make the bars right-side-up, you need to change the way the y coordinate is calculated.
It needs to account for both the height of the bar and the total height of the SVG area. The height of the SVG area is 100.
If you have a data point of 0 in the set, you would want the bar to start at the bottom of the SVG area (not the top). To do this, the y coordinate needs a value of 100.
If the data point value were 1, you would start with a y coordinate of 100 to set the bar at the bottom.
Then you need to account for the height of the bar of 1, so the final y coordinate would be 99.
The y coordinate that is y = heightOfSVG - heightOfBar would place the bars right-side-up. 
Note: In general, the relationship is y = h - m * d, where m is the constant that scales the data points. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => {
          return h - 3*d;
         })
         .attr("width", 25)
         .attr("height", (d, i) => 3 * d);
    </script>
</body>

<!-- In SVG, a rect shape is colored with the fill attribute.
It supports hex codes, color names, and rgb values, as well as more complex options like gradients and transparency. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => h - 3 * d)
         .attr("width", 25)
         .attr("height", (d, i) => 3 * d)
         .attr("fill","navy")
    </script>
</body>

<!-- D3 lets you label a graph element, such as a bar, using the SVG text element.
Like the rect element, a text element needs to have x and y attributes, to place it on the SVG.
It also needs to access the data to display those values. D3 gives you a high level of control over how you label your bars. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => h - 3 * d)
         .attr("width", 25)
         .attr("height", (d, i) => 3 * d)
         .attr("fill", "navy");
  
      svg.selectAll("text")
         .data(dataset)
         .enter()
         .append("text")
         .attr("x", (d, i) => i * 30)
         .attr("y",(d, i) => h - 3 - 3 * d)
         .text((d) => d)
    </script>
<body>

<!-- D3 methods can add styles to the bar labels. The fill attribute sets the color of the text for a text node.
The style() method sets CSS rules for other styles, such as font-family or font-size. -->

<body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => h - 3 * d)
         .attr("width", 25)
         .attr("height", (d, i) => d * 3)
         .attr("fill", "navy");
  
      svg.selectAll("text")
         .data(dataset)
         .enter()
         .append("text")
         .text((d) => d)
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => h - (3 * d) - 3)
         .style("font-size","25px")
         .attr("fill","red")
    </script>
</body>

<!-- So far, the styling for the rectangles is applied with the built-in D3 and SVG methods, but you can use CSS as well.
You set the CSS class on the SVG elements with the attr() method.
Then the :hover pseudo-class for your new class holds the style rules for any hover effects.-->

<style>
    .bar:hover {
      fill: brown;
    }
  </style>
  <body>
    <script>
      const dataset = [12, 31, 22, 17, 25, 18, 29, 14, 9];
  
      const w = 500;
      const h = 100;
  
      const svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);
  
      svg.selectAll("rect")
         .data(dataset)
         .enter()
         .append("rect")
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => h - 3 * d)
         .attr("width", 25)
         .attr("height", (d, i) => 3 * d)
         .attr("fill", "navy")
         .attr("class","bar")
      svg.selectAll("text")
         .data(dataset)
         .enter()
         .append("text")
         .text((d) => d)
         .attr("x", (d, i) => i * 30)
         .attr("y", (d, i) => h - (3 * d) - 3);
  
    </script>
</body>

