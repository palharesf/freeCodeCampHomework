Exercise link: https://www.freecodecamp.org/learn/quality-assurance/advanced-node-and-express
Project link: 

A template engine enables you to use static template files (such as those written in Pug) in your app.
At runtime, the template engine replaces variables in a template file with actual values which can be supplied by your server.
Then it transforms the template into a static HTML file that is sent to the client.
This approach makes it easier to design an HTML page and allows for displaying variables on the page without needing to make an API call from the client.

Express needs to know which template engine you are using.
Use the set method to assign pug as the view engine property's value:

    app.set('view engine', 'pug');

After that, add another set method that sets the views property of your app to point to the ./views/pug directory.
This tells Express to render all views relative to that directory.
Finally, use res.render() in the route for your home page, passing index as the first argument.
This will render the pug template.

One of the greatest features of using a template engine is being able to pass variables from the server to the template file before rendering it to HTML.
In your Pug file, you're able to use a variable by referencing the variable name as #{variable_name} inline with other text on an element or by using an equal sign on the element without a space such as p=variable_name which assigns the variable's value to the p element's text.
Pug is all about using whitespace and tabs to show nested elements and cutting down on the amount of code needed to make a beautiful site.

Your index.pug file included in your project, uses the variables title and message.
Pass those from your server to the Pug file by adding an object as a second argument to your res.render call with the variables and their values.

    res.render('index', { title: 'Hello', message: 'Please log in' });

It's time to set up Passport so you can finally start allowing a user to register or log in to an account.
In addition to Passport, you will use Express-session to handle sessions.
Express-session has a ton of advanced features you can use, but for now you are just going to use the basics.
Using this middleware saves the session id as a cookie in the client, and allows us to access the session data using that id on the server.
This way, you keep personal account information out of the cookie used by the client to tell to your server clients are authenticated and keep the key to access the data stored on the server.

You will need to set up the session settings and initialize Passport.
First, create the variables session and passport to require express-session and passport respectively.
Then, set up your Express app to use the session by defining the following options:

    app.use(session({
    secret: process.env.SESSION_SECRET,
    resave: true,
    saveUninitialized: true,
    cookie: { secure: false }
    }));

Be sure to add SESSION_SECRET to your .env file, and give it a random value.
This is used to compute the hash used to encrypt your cookie!
After you do all that, tell your express app to use passport.initialize() and passport.session().

Serialization and deserialization are important concepts in regard to authentication.
To serialize an object means to convert its contents into a small key that can then be deserialized into the original object.
This is what allows us to know who has communicated with the server without having to send the authentication data, like the username and password, at each request for a new page.
To set this up properly, you need to have a serialize function and a deserialize function. In Passport, these can be created with:

    passport.serializeUser(cb);
    passport.deserializeUser(cb);

The callback function passed to serializeUser is called with two arguments: the full user object, and a callback used by passport.
The callback expects two arguments: An error, if any, and a unique key to identify the user that should be returned in the callback. 
You will use the user's _id in the object. This is guaranteed to be unique, as it is generated by MongoDB.

Similarly, deserializeUser is called with two arguments: the unique key, and a callback function.
This callback expects two arguments: An error, if any, and the full user object. To get the full user object, make a query search for a Mongo _id, as shown below:

    passport.serializeUser((user, done) => {
        done(null, user._id);
    });

    passport.deserializeUser((id, done) => {
        myDataBase.findOne({ _id: new ObjectID(id) }, (err, doc) => {
            done(null, null);
        });
    });

The ObjectID class comes from the mongodb package. Declare this class with:

    const { ObjectID } = require('mongodb');

You are not loading an actual user object since the database is not set up.
Connect to the database once, when you start the server, and keep a persistent connection for the full life-cycle of the app.
To do this, add your database's connection string (for example: mongodb+srv://<username>:<password>@cluster0-jvwxi.mongodb.net/?retryWrites=true&w=majority) to the environment variable MONGO_URI.
This is used in the connection.js file.

Now you want to connect to your database, then start listening for requests.
The purpose of this is to not allow requests before your database is connected or if there is a database error.
To accomplish this, encompass your serialization and app routes in the following code:

    myDB(async client => {
        const myDataBase = await client.db('database').collection('users');

        // Be sure to change the title
        app.route('/').get((req, res) => {
            // Change the response to render the Pug template
            res.render('index', {
                title: 'Connected to Database',
                message: 'Please login'
            });
        });

        // Serialization and deserialization here...

        // Be sure to add this...
        }).catch(e => {
            app.route('/').get((req, res) => {
                res.render('index', { title: e, message: 'Unable to connect to database' });
        });
    });
    // app.listen out here...

A strategy is a way of authenticating a user. 
You can use a strategy for allowing users to authenticate based on locally saved information (if you have them register first) or from a variety of providers such as Google or GitHub.
For this project, we will use Passport middleware.
Passport provides a comprehensive set of strategies that support authentication using a username and password, GitHub, Google, and more.

passport-local@~1.0.0 has already been added as a dependency. Add it to your server as follows:

    const LocalStrategy = require('passport-local');

Make sure this (as well as everything from this point on) is encapsulated in the database connection since it relies on it!:

    passport.use(new LocalStrategy((username, password, done) => {
        myDataBase.findOne({ username: username }, (err, user) => {
            console.log(`User ${username} attempted to log in.`);
            if (err) return done(err);
            if (!user) return done(null, false);
            if (password !== user.password) return done(null, false);
            return done(null, user);
        });
    }));

This is defining the process to use when you try to authenticate someone locally.
First, it tries to find a user in your database with the username entered.
Then, it checks for the password to match.
Finally, if no errors have popped up that you checked for (e.g. an incorrect password), the user object is returned and they are authenticated.
Many strategies are set up using different settings.
Generally, it is easy to set it up based on the README in that strategy's repository.
A good example of this is the GitHub strategy where you don't need to worry about a username or password because the user will be sent to GitHub's auth page to authenticate.
As long as they are logged in and agree then GitHub returns their profile for you to use.

In the index.pug file supplied, there is a login form.
It is hidden because of the inline JavaScript if showLogin with the form indented after it.

In the res.render for that page, add a new variable to the object, showLogin: true.
When you refresh your page, you should then see the form!
This form is set up to POST on /login.
So, this is where you should set up to accept the POST request and authenticate the user.

To authenticate on the /login POST route, you need to add a middleware to do so before then sending a response.
This is done by just passing another argument with the middleware before with your response.
The middleware to use is passport.authenticate('local').

passport.authenticate can also take some options as an argument such as { failureRedirect: '/' } which is incredibly useful, so be sure to add that in as well.
Add a response after using the middleware (which will only be called if the authentication middleware passes) that redirects the user to /profile.
If the authentication was successful, the user object will be saved in req.user.
At this point, if you enter a username and password in the form, it should redirect to the home page /, and the console of your server should display 'User {USERNAME} attempted to log in.', since we currently cannot login a user who isn't registered.

As is, any user can just go to /profile whether they have authenticated or not by typing in the URL.
You want to prevent this by checking if the user is authenticated first before rendering the profile page.
This is the perfect example of when to create a middleware.
The challenge here is creating the middleware function ensureAuthenticated(req, res, next), which will check if a user is authenticated by calling Passport's isAuthenticated method on the request which checks if req.user is defined.
If it is, then next() should be called. Otherwise, you can just respond to the request with a redirect to your homepage to login.

An implementation of this middleware is:

    function ensureAuthenticated(req, res, next) {
        if (req.isAuthenticated()) {
            return next();
        }
        res.redirect('/');
    };

Create the above middleware function, then pass ensureAuthenticated as middleware to requests for the profile page before the argument to the GET request:

    app
        .route('/profile')
        .get(ensureAuthenticated, (req,res) => {
            res.render('profile');
        });

Now that you can ensure the user accessing the /profile is authenticated, you can use the information contained in req.user on your page.
Pass an object containing the property username and value of req.user.username as the second argument for the render method of the profile view.
Then, go to your profile.pug view, and add the following line below the existing h1 element, and at the same level of indentation:

    h2.center#welcome Welcome, #{username}!

This creates an h2 element with the class center and id welcome containing the text Welcome, followed by the username.
Also, in profile.pug, add a link referring to the /logout route, which will host the logic to unauthenticate a user:

    a(href='/logout') Logout

Creating the logout logic is easy.
The route should just unauthenticate the user, and redirect to the home page instead of rendering any view.
In passport, unauthenticating a user is as easy as just calling req.logout() before redirecting. Add this /logout route to do that:

    app.route('/logout')
        .get((req, res) => {
            req.logout();
            res.redirect('/');
        });

You may have noticed that you are not handling missing pages (404).
The common way to handle this in Node is with the following middleware.
Go ahead and add this in after all your other routes:

    app.use((req, res, next) => {
        res.status(404)
            .type('text')
            .send('Not Found');
        });

For user creation, we can enable the pug elements to display:

    showRegistration: true

And then proceed building the logic on the server.js file. It goes as:

    - Register the new user
    - Authenticate the new user
    - Redirect to /profile

For the first step:

    - Query database with findOne
    - If there is an error, call next with the error
    - If a user is returned, redirect back to home
    - If a user is not found and no errors occur, then insertOne into the database with the username and password. As long as no errors occur there, call next to go to step 2, authenticating the new user, which you already wrote the logic for in your POST /login route.

Code:

    app.route('/register')
        .post((req, res, next) => {
            myDataBase.findOne({ username: req.body.username }, (err, user) => {
                if (err) {
                    next(err);
                } else if (user) {
                    res.redirect('/');
                } else {
                    myDataBase.insertOne({
                        username: req.body.username,
                        password: req.body.password
                    },
                        (err, doc) => {
                            if (err) {
                                res.redirect('/');
                            } else {
                            // The inserted document is held within
                            // the ops property of the doc
                            next(null, doc.ops[0]);
                            }
                        }
                    )
                }
            })
        },
            passport.authenticate('local', { failureRedirect: '/' }),
            (req, res, next) => {
                res.redirect('/profile');
            }
        );

Going back to the information security section, you may remember that storing plaintext passwords is never okay.
Now it is time to implement BCrypt to solve this issue.

bcrypt@~5.0.0 has already been added as a dependency, so require it in your server.
You will need to handle hashing in 2 key areas: where you handle registering/saving a new account, and when you check to see that a password is correct on login.
Currently on your registration route, you insert a user's plaintext password into the database like so: password: req.body.password.
Hash the passwords instead by adding the following before your database logic: const hash = bcrypt.hashSync(req.body.password, 12);, and replacing the req.body.password in the database saving with just password: hash.
On your authentication strategy, you check for the following in your code before completing the process: if (password !== user.password) return done(null, false);.
After making the previous changes, now user.password is a hash.
Before making a change to the existing code, notice how the statement is checking if the password is not equal then return non-authenticated.
With this in mind, change that code to look as follows to properly check the password entered against the hash:

    if (!bcrypt.compareSync(password, user.password)) { 
        return done(null, false);
    }

That is all it takes to implement one of the most important security features when you have to store passwords.

For complex projects, it can be difficult to manage complexity in a single file. If we split server.js into two other files, routes.js and auth.js, it makes it more manageable.
Both should be start with:

    module.exports = function (app, myDataBase) {

    }

And we can reference them back to the server.js through the following statement:

    const routes = require('./routes.js');
    const auth  = require('./auth.js');

We should also remember to add all the dependencies in the new files, as well as removing unused ones from the server file.

For social implementation, we have a basic framework:

    User clicks a button or link sending them to your route to authenticate using a specific strategy (e.g. GitHub).
    Your route calls passport.authenticate('github') which redirects them to GitHub.
    The page the user lands on, on GitHub, allows them to login if they aren't already.
        It then asks them to approve access to their profile from your app.
    The user is then returned to your app at a specific callback url with their profile if they are approved.
    They are now authenticated, and your app should check if it is a returning profile, or save it in your database if it is not.

Strategies with OAuth require you to have at least a Client ID and a Client Secret which is a way for the service to verify who the authentication request is coming from and if it is valid.
These are obtained from the site you are trying to implement authentication with, such as GitHub, and are unique to your app--THEY ARE NOT TO BE SHARED and should never be uploaded to a public repository or written directly in your code. 
A common practice is to put them in your .env file and reference them like so: process.env.GITHUB_CLIENT_ID.

Set the homepage URL to your homepage (not the project code's URL), and set the callback URL to the same homepage URL with /auth/github/callback appended to the end.
Save the client ID and your client secret in your project's .env file as GITHUB_CLIENT_ID and GITHUB_CLIENT_SECRET.
In the routes.js file, add showSocialAuth: true to the homepage route, after showRegistration: true.
Create 2 routes accepting GET requests: /auth/github and /auth/github/callback.
The first should only call passport to authenticate 'github'.
The second should call passport to authenticate 'github' with a failure redirect to /, and then if that is successful redirect to /profile (similar to your last project).

An example of how /auth/github/callback should look is similar to how you handled a normal login:

    app.route('/login')
        .post(passport.authenticate('local', { failureRedirect: '/' }), (req,res) => {
            res.redirect('/profile');
        });

The last part of setting up your GitHub authentication is to create the strategy itself.
passport-github@~1.1.0 has already been added as a dependency, so require it in your auth.js file as GithubStrategy like this: const GitHubStrategy = require('passport-github').Strategy;.
Do not forget to require and configure dotenv to use your environment variables.

To set up the GitHub strategy, you have to tell Passport to use an instantiated GitHubStrategy, which accepts 2 arguments: an object (containing clientID, clientSecret, and callbackURL) and a function to be called when a user is successfully authenticated, which will determine if the user is new and what fields to save initially in the user's database object.
This is common across many strategies, but some may require more information as outlined in that specific strategy's GitHub README.
For example, Google requires a scope as well which determines what kind of information your request is asking to be returned and asks the user to approve such access.

The current strategy you are implementing authenticates users using a GitHub account and OAuth 2.0 tokens.
The client ID and secret obtained when creating an application are supplied as options when creating the strategy.
The strategy also requires a verify callback, which receives the access token and optional refresh token, as well as profile which contains the authenticated user's GitHub profile.
The verify callback must call cb providing a user to complete authentication.

Here's how your new strategy should look at this point:

    passport.use(new GitHubStrategy({
        clientID: process.env.GITHUB_CLIENT_ID,
        clientSecret: process.env.GITHUB_CLIENT_SECRET,
        callbackURL: /*INSERT CALLBACK URL ENTERED INTO GITHUB HERE*/
    },
        function(accessToken, refreshToken, profile, cb) {
            console.log(profile);
            //Database logic here with callback containing your user object
        }
    ));

The final part of the strategy is handling the profile returned from GitHub.
We need to load the user's database object if it exists, or create one if it doesn't, and populate the fields from the profile, then return the user's object.
GitHub supplies us a unique id within each profile which we can use to search with to serialize the user with (already implemented).

    myDataBase.findOneAndUpdate(
        { id: profile.id },
        {
            $setOnInsert: {
                id: profile.id,
                username: profile.username,
                name: profile.displayName || 'John Doe',
                photo: profile.photos[0].value || '',
                email: Array.isArray(profile.emails)
                    ? profile.emails[0].value
                    : 'No public email',
                created_on: new Date(),
                provider: profile.provider || ''
            },
            $set: {
                last_login: new Date()
            },
            $inc: {
                login_count: 1
            }
        },
        { upsert: true, new: true },
        (err, doc) => {
            return cb(null, doc.value);
        }
    );

findOneAndUpdate allows you to search for an object and update it.
If the object doesn't exist, it will be inserted and made available to the callback function.
In this example, we always set last_login, increment the login_count by 1, and only populate the majority of the fields when a new object (new user) is inserted.
Notice the use of default values.
Sometimes a profile returned won't have all the information filled out or the user will keep it private.
In this case, you handle it to prevent an error.

In the routes.js file, add a GET route pointing to /chat which makes use of ensureAuthenticated, and renders chat.pug, with { user: req.user } passed as an argument to the response.
Now, alter the existing /auth/github/callback route to set the req.session.user_id = req.user.id, and redirect to /chat.

socket.io@~2.3.0 has already been added as a dependency, so require/instantiate it in your server as follows with http (comes built-in with Nodejs):

    const http = require('http').createServer(app);
    const io = require('socket.io')(http);

Now that the http server is mounted on the express app, you need to listen from the http server.
Change the line with app.listen to http.listen.

The first thing needing to be handled is listening for a new connection from the client.
The on keyword does just that- listen for a specific event.
It requires 2 arguments: a string containing the title of the event that's emitted, and a function with which the data is passed through.
In the case of our connection listener, use socket to define the data in the second argument.
A socket is an individual client who is connected.

To listen for connections to your server, add the following within your database connection:

    io.on('connection', socket => {
        console.log('A user has connected');
    });

Now for the client to connect, you just need to add the following to your client.js which is loaded by the page after you've authenticated:

    /*global io*/
    let socket = io();

The comment suppresses the error you would normally see since 'io' is not defined in the file.
You have already added a reliable CDN to the Socket.IO library on the page in chat.pug.
Note:io() works only when connecting to a socket hosted on the same url/server.
For connecting to an external socket hosted elsewhere, you would use io.connect('URL');.

Emit is the most common way of communicating we will use.
When you emit something from the server to 'io', you send an event's name and data to all the connected sockets.
A good example of this concept would be emitting the current count of connected users each time a new user connects!

Start by adding a variable to keep track of the users, just before where you are currently listening for connections.

    let currentUsers = 0;

Now, when someone connects, you should increment the count before emitting the count.
So, you will want to add the incrementer within the connection listener.

    ++currentUsers;

Finally, after incrementing the count, you should emit the event (still within the connection listener).
The event should be named 'user count', and the data should just be the currentUsers.

    io.emit('user count', currentUsers);

Now, you can implement a way for your client to listen for this event!
Similar to listening for a connection on the server, you will use the on keyword.

    socket.on('user count', function(data) {
        console.log(data);
    });

Now, try loading up your app, authenticate, and you should see in your client console '1' representing the current user count!
Try loading more clients up, and authenticating to see the number go up.


